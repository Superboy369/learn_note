# 操作系统八股文
## 什么是操作系统？请简要概述一下
操作系统是管理和分配计算机硬件资源和软件资源的一种软件，他协调了不同进程对资源的占用，提高了对计算机资源的使用效率。比如：虚拟内存的抽象提高计算机内存的使用效率，进程的抽象提高CPU的使用效率和不同进程之间的并发和并行，文件系统的抽象提高了外存的使用效率。
## 操作系统的分类有哪些？
操作系统有三类：批处理操作系统、分时操作系统、实时操作系统，兼顾批处理和分时的操作系统为通用操作系统，通用操作系统有Windows、Linux、MacOS。
## 什么是内核态和用户态？
为了防止恶意用户程序破坏操作系统关键代码和资源，操作系统将CPU的执行状态分为内核态和用户态，用户态下只能执行非特权指令，且只能访问用户地址空间，内核态下能执行特权指令，且能访问所有地址空间。
## 特权指令和非特权指令
* 特权指令：清内存指令、置时钟指令、修改页表基址寄存器指令。
* 非特权指令：逻辑运算指令。
## 内核态和用户态之间的切换
* 用户态->内核态：内中断时用户态下执行特殊指令ecall，切换CPU位状态用户态为内核态，外中断时信号线改变cpu位状态。        
* 内核态->用户态：内中断返回时内核态下执行和ecall相反的特殊指令sret，切换CPU位状态内核态为用户态。
* ecall和sret指令的四件事情：
  * 关中断 */* 开中断
  * 用户态->内核态 */* 内核态->用户态
  * pc->sepc、stvec->pc */* sepc->pc
  * 跳转至pc所指地址继续执行汇编代码
## 并发和并行
并发是不同进程交替在同一个CPU上面运行，并行是不同进程同时在不同CPU核上运行。
## 进程切换过程
cpu的执行流不断在不同进程和cpu调度器代码中来回切换。进程要么主动调用sleep()释放cpu，sleep()最终调用swtch()切换到cpu调度器代码中的swtch()，要么当进程被时钟中断后被动调用yield()释放cpu，yield()最终调用swtch()切换到cpu调度器代码中的swtch()（切换当前进程上下文为cpu调度器上下文）。cpu调度器则会从swtch()继续执行，寻找下一个RUNNABLE的进程，并调用swtch()切换到被调度进程代码中的swtch()（切换cpu调度器上下文为被调度进程上下文），这样就完成了进程的调度和进程上下文的保存切换。
```c
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
    int which_dev = 0;
    if((r_sstatus() & SSTATUS_SPP) != 0)
        panic("usertrap: not from user mode");
    // send interrupts and exceptions to kerneltrap(),
    // since we're now in the kernel.
    w_stvec((uint64)kernelvec);
    struct proc *p = myproc();
    // save user program counter.
    p->trapframe->epc = r_sepc();
    if(r_scause() == 8){
        // system call
        if(p->killed)
            exit(-1);
        // sepc points to the ecall instruction,
        // but we want to return to the next instruction.
        p->trapframe->epc += 4;
        // an interrupt will change sstatus &c registers,
        // so don't enable until done with those registers.
        intr_on();
        syscall();
    } else if((which_dev = devintr()) != 0){
        // ok
    } else {
        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
        printf(" sepc=%p stval=%p\n", r_sepc(), r_stval());
        p->killed = 1;
    }
    if(p->killed)
        exit(-1);
    // give up the CPU if this is a timer interrupt.
    if(which_dev == 2)
        yield();  // 当前进程在时钟中断时内核调用yield()被动释放cpu
    usertrapret();
}
```
```c
// Give up the CPU for one scheduling round.
void
yield(void)
{
    struct proc *p = myproc();
    acquire(&p->lock);  
    p->state = RUNNABLE;
    sched();  // 当前进程被动调用sched()
    release(&p->lock);  
}
```
```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
    struct proc *p = myproc();
    // Must acquire p->lock in order to
    // change p->state and then call sched.
    // Once we hold p->lock, we can be
    // guaranteed that we won't miss any wakeup
    // (wakeup locks p->lock),
    // so it's okay to release lk.
    if(lk != &p->lock){ //DOC: sleeplock0
        acquire(&p->lock); //DOC: sleeplock1  
        release(lk); 
    }
    // Go to sleep.
    p->chan = chan;
    p->state = SLEEPING;
    sched();  // 当前进程主动调用sleep()放弃cpu，主动调用sched()
    // Tidy up.
    p->chan = 0;
    // Reacquire original lock.
    if(lk != &p->lock){
        release(&p->lock);  
        acquire(lk);  
    }
}
```
```c
// Switch to scheduler. Must hold only p->lock
// and have changed proc->state. Saves and restores
// intena because intena is a property of this
// kernel thread, not this CPU. It should
// be proc->intena and proc->noff, but that would
// break in the few places where a lock is held but
// there's no process.
void
sched(void)
{
    int intena;
    struct proc *p = myproc();
    if(!holding(&p->lock))
        panic("sched p->lock");
    if(mycpu()->noff != 1)
    panic("sched locks");
    if(p->state == RUNNING)
        panic("sched running");
    if(intr_get())
        panic("sched interruptible");
    intena = mycpu()->intena;
    swtch(&p->context, &mycpu()->context);  // sched()最终调用swtch()保存当前进程上下文，回复cpu调度器上下文 
    mycpu()->intena = intena;
}
```
```c
// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns. It loops, doing:
// - choose a process to run.
// - swtch to start running that process.
// - eventually that process transfers control
// via swtch back to the scheduler.
void
scheduler(void)
{
    struct proc *p;
    struct cpu *c = mycpu();
    c->proc = 0;
    for(;;){
        // Avoid deadlock by ensuring that devices can interrupt.
        intr_on();
        int nproc = 0;
            for(p = proc; p < &proc[NPROC]; p++) {
                acquire(&p->lock); 
                if(p->state != UNUSED) {
                    nproc++;
                }
                if(p->state == RUNNABLE) {
                    // Switch to chosen process. It is the process's job
                    // to release its lock and then reacquire it
                    // before jumping back to us.
                    p->state = RUNNING;
                    c->proc = p;
                    swtch(&c->context, &p->context);  // 每个cpu调度器scheduler()调用swtch()保存cpu调度器的上下文，回复被调度进程的上下文
                    // Process is done running for now.
                    // It should have changed its p->state before coming back.
                    c->proc = 0;
                }
                release(&p->lock); 
            }
            if(nproc <= 2) { // only init and sh exist
            intr_on();
            asm volatile("wfi");
        }
    }
}
```
## 锁
锁在xv6操作系统中就是一个结构体，里面包含了locked字段和一些用于debug的字段（name、持有锁的cpu）。
* acquire(&lock)会先关中断，再利用硬件原子执行test_and_set locked字段。
* release(&lock)会先利用硬件原子执行test_and_set locked字段，再开中断。
* 开关中断意味着在临界区代码中无法中断，因为在临界区中断可能导致死锁（普通程序在acquire()之后被中断，之后中断处理程序对同一把锁上锁导致死锁）。
## 进程切换中对于进程锁和非进程锁的行为
* 在进程切换前要持有当前进程的锁并且释放出当前进程锁的其他锁之后在切换至其他进程。
* 在进程切换之前/后（yield()和sleep()调用sched()(swtch())之前/后）要持有/释放当前要下处理机的进程的锁的原因是：如果不持有当前进程锁，多个cpu scheduler()在调度进程时都调度同一个进程上处理机。
* 在进程切换之前/后（yield()和sleep()调用sched()/swtch()之前/后）要释放/持有除当前要下处理机的进程的锁之外的其他所有设备锁的原因是：如果不释放，会导致死锁，当调度到的其他进程在对该设备上锁时会关中断并进入自旋等待，而持有该设备锁的进程由于该cpu关了中断而无法上处理机释放锁，导致死锁。
```c
// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns. It loops, doing:
// - choose a process to run.
// - swtch to start running that process.
// - eventually that process transfers control
// via swtch back to the scheduler.
void
scheduler(void)
{
    struct proc *p;
    struct cpu *c = mycpu();
    c->proc = 0;
    for(;;){
        // Avoid deadlock by ensuring that devices can interrupt.
        intr_on();
        int nproc = 0;
            for(p = proc; p < &proc[NPROC]; p++) {
                acquire(&p->lock);  // @@@获取当前进程锁
                if(p->state != UNUSED) {
                    nproc++;
                }
                if(p->state == RUNNABLE) {
                    // Switch to chosen process. It is the process's job
                    // to release its lock and then reacquire it
                    // before jumping back to us.
                    p->state = RUNNING;
                    c->proc = p;
                    swtch(&c->context, &p->context);
                    // Process is done running for now.
                    // It should have changed its p->state before coming back.
                    c->proc = 0;
                }
                release(&p->lock);  // @@@释放当前进程锁
            }
            if(nproc <= 2) { // only init and sh exist
            intr_on();
            asm volatile("wfi");
        }
    }
}
```
```c
// Give up the CPU for one scheduling round.
void
yield(void)
{
    struct proc *p = myproc();
    acquire(&p->lock);  // @@@获取当前进程锁
    p->state = RUNNABLE;
    sched();
    release(&p->lock);  // @@@释放当前进程锁
}
```
```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
    struct proc *p = myproc();
    // Must acquire p->lock in order to
    // change p->state and then call sched.
    // Once we hold p->lock, we can be
    // guaranteed that we won't miss any wakeup
    // (wakeup locks p->lock),
    // so it's okay to release lk.
    if(lk != &p->lock){ //DOC: sleeplock0
        acquire(&p->lock); //DOC: sleeplock1  // @@@获取当前进程锁
        release(lk);  // @@@@释放非进程锁
    }
    // Go to sleep.
    p->chan = chan;
    p->state = SLEEPING;
    sched();
    // Tidy up.
    p->chan = 0;
    // Reacquire original lock.
    if(lk != &p->lock){
        release(&p->lock);  // @@@释放当前进程锁
        acquire(lk);  // @@@@重新对非进程锁上锁
    }
}
```
```c
// Wake up all processes sleeping on chan.
// Must be called without any p->lock.
void
wakeup(void *chan)
{
    struct proc *p;
    for(p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);  // @@@获取当前进程锁
        if(p->state == SLEEPING && p->chan == chan) {
            p->state = RUNNABLE;
        }
        release(&p->lock);  // @@@释放当前进程锁
    }
}
```
```c
// handle a uart interrupt, raised because input has
// arrived, or the uart is ready for more output, or
// both. called from trap.c.
void
uartintr(void)
{
    // read and process incoming characters.
    while(1){
        int c = uartgetc();
        if(c == -1)
            break;
        consoleintr(c);
    }
    // send buffered characters.
    acquire(&uart_tx_lock);  // @@@@互斥访问uart
    uartstart();
    release(&uart_tx_lock);  // @@@@互斥访问uart
}
```
## 进程的退出和终止
xv6有两种停止进程的方式：1.exit()，2.kill()：
* exit():exit()只是关文件，设置当前进程state为ZOMBIE，并调用sched()，真正资源的free在父进程被调度运行wait()时，子进程的资源由父进程来关闭。init()进程会作为所有无父进程进程的父进程调用wait()释放其子进程的资源。
* kill():kill()系统调用只是设置p->killed字段为1，并设置进程state为RUNNABLE，进程被调度运行时用于中断陷入usertrap()中，在usertrap()中判断p->killed为1调用exit(-1)。
* 所有main()函数最后都会隐式的调用exit()函数来让父进程释放资源。
* 这些资源包括页表、trapframe、物理页、一系列proc结构体中的数据。
```c
// Exit the current process. Does not return.
// An exited process remains in the zombie state
// until its parent calls wait().
void
exit(int status)
{
    struct proc *p = myproc();
    if(p == initproc)
        panic("init exiting");
    // Close all open files.
    for(int fd = 0; fd < NOFILE; fd++){
        if(p->ofile[fd]){
            struct file *f = p->ofile[fd];
            fileclose(f);
            p->ofile[fd] = 0;
        }
    }
    begin_op();
    iput(p->cwd);
    end_op();
    p->cwd = 0;
        // we might re-parent a child to init. we can't be precise about
    // waking up init, since we can't acquire its lock once we've
    // acquired any other proc lock. so wake up init whether that's
    // necessary or not. init may miss this wakeup, but that seems
    // harmless.
    acquire(&initproc->lock);
    wakeup1(initproc);
    release(&initproc->lock);
    // grab a copy of p->parent, to ensure that we unlock the same
    // parent we locked. in case our parent gives us away to init while
    // we're waiting for the parent lock. we may then race with an
    // exiting parent, but the result will be a harmless spurious wakeup
    // to a dead or wrong process; proc structs are never re-allocated
    // as anything else.
    acquire(&p->lock);
    struct proc *original_parent = p->parent;
    release(&p->lock);
    // we need the parent's lock in order to wake it up from wait().
    // the parent-then-child rule says we have to lock it first.
    acquire(&original_parent->lock);
    acquire(&p->lock);
    // Give any children to init.
    reparent(p);
    // Parent might be sleeping in wait().
    wakeup1(original_parent);
    p->xstate = status;
    p->state = ZOMBIE;
    release(&original_parent->lock);
    // Jump into the scheduler, never to return.
    sched();
    panic("zombie exit");
}
```
```c
// Wait for a child process to exit and return its pid.
// Return -1 if this process has no children.
int
wait(uint64 addr)
{
    struct proc *np;
    int havekids, pid;
    struct proc *p = myproc();
    // hold p->lock for the whole time to avoid lost
    // wakeups from a child's exit().
    acquire(&p->lock);
    for(;;){
        // Scan through table looking for exited children.
        havekids = 0;
        for(np = proc; np < &proc[NPROC]; np++){
            // this code uses np->parent without holding np->lock.
            // acquiring the lock first would cause a deadlock,
            // since np might be an ancestor, and we already hold p->lock.
            if(np->parent == p){
                // np->parent can't change between the check and the acquire()
                // because only the parent changes it, and we're the parent.
                acquire(&np->lock);
                havekids = 1;
                if(np->state == ZOMBIE){
                    // Found one.
                    pid = np->pid;
                    if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,sizeof(np->xstate)) < 0) {
                        release(&np->lock);
                        release(&p->lock);
                        return -1;
                    }
                    freeproc(np);
                    release(&np->lock);
                    release(&p->lock);
                    return pid;
                }
                release(&np->lock);
            }
        }
        // No point waiting if we don't have any children.
        if(!havekids || p->killed){
            release(&p->lock);
            return -1;
        }
        // Wait for a child to exit.
        sleep(p, &p->lock); //DOC: wait-sleep
    }
}
```
```c
// Kill the process with the given pid.
// The victim won't exit until it tries to return
// to user space (see usertrap() in trap.c).
int
kill(int pid)
{
    struct proc *p;
    for(p = proc; p < &proc[NPROC]; p++){
        acquire(&p->lock);
        if(p->pid == pid){
            p->killed = 1;
            if(p->state == SLEEPING){
                // Wake process from sleep().
                p->state = RUNNABLE;
            }
            release(&p->lock);
            return 0;
        }
        release(&p->lock);
    }
    return -1;
}
```

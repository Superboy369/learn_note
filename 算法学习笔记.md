# 算法学习笔记
## 1 一些口诀
- dijkstra 小根堆出堆后判重
- 只有01权点最短路 dijkstra 双端队列出队后判重
- spfa 队列在不在
- bfs 队列入队前判重
- 二分 0左右、1右左（二分 左左右左、右右左右）
- dfs特顺根剪参
## 2 经典算法
### 2.1 二分
#### 2.1.1整数二分
口诀：左左右左、右右左右
```c
int find(int k,int option){
    if(option == 0){ // 求左边界
        int l = 0,r = n - 1;
        while(l < r){
            int mid = l + (r - l >> 1);
            if(arr[mid] >= k){
                r = mid;
            }else{
                l = mid + 1;
            }
        }
    }else{ // 求右边界
        int l = 0,r = n - 1;
        while(l < r){
            int mid = l + (r - l + 1 >> 1);
            if(arr[mid] <= k){
                l = mid;
            }else{
                r = mid - 1;
            }
        }
    }
}
```
#### 2.1.2浮点数二分
以求n的立方根为例：
```c
double sqrt_3(double n){
    double l = -10000.0,r = 10000.0;
    while(r - l > 0.0000001){
        double mid = (l + r) / 2;
        if(mid * mid * mid <= n){
            l = mid;
        }else{
            r = mid;
        }
    }
    return l;
}
```
### 2.2 欧几里得算法求最大公约数\最小公倍数
```c
int gcd(int a,int b){ // 求最大公约数
	return b ? gcd(b,a % b) : a;
}
int minbei = a * b / gcd(a,b);
```
### 2.3 并查集
```c
// 朴素并查集
int fth[N];//存储每个点的祖宗节点
// 返回x的祖宗节点
int find(int x){
    if(fth[x] != x) fth[x] = find(fth[x]);
    return fth[x];
}

// 初始化，假定节点编号是1~n
for(int i = 1;i <= n;i ++ ) fth[i] = i;

// 合并a和b所在的集合
fth[find(a)] = find(b);
```
### 2.4 dijkstra算法求最短路
口诀：dijkstra小根堆出堆后判重
```c
bool st[N];
int dist[N];
int dijsktra(){
    memset(dist,0x3f,sizeof dist);
    priority_queue<PII,vector<PII>,greater<PII> > heap;
    dist[1] = 0;
    heap.push({0,1});

    while(heap.size()){
        PII t = heap.top();
        heap.pop();

        int ver = t.second,distance = t.first;
        if(st[ver]) continue;
        st[ver] = true;

        for(int i = h[ver];i != -1;i = ne[i]){
            int j = e[i];
            if(dist[j] > distance + w[i]){
                    dist[j] = distance + w[i];
                    heap.push({dist[j],j});
            }
        } 
    }

    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}
```
### 2.5 KMP算法模式匹配
```c
int ne[N];
// 求ne[]数组
for(int i = 2,j = 1;i <= m;i ++ ){
    while(j != 1 && str_p[i] != str_p[j]){
        j = ne[j - 1] + 1;
    }
    if(str_p[i] == str_p[j]){
        j ++ ;
    }
    ne[i] = j - 1;
}
// 模式匹配过程
for(int i = 1,j = 1;i <= n;i ++ ){
    while(j != 1 && str_s[i] != str_p[j]){
        j = ne[j - 1] + 1;
    }
    if(str_s[i] == str_p[j]){
        j ++ ;
    }
    if(j = n + 1){
        cout << i - n;
        j = ne[j - 1] + 1;
    }
}
```
### 2.6 bfs深搜
口诀：bfs队列入队前判重
```c
int bfs(){
    queue<int> que;
    que.push(0);
    st[0] = true;

    while(que.size()){
        int t = que.front();
        que.pop();

        for(int i = h[t];i != -1;i = ne[i]){
            int j = e[i];
            if(!st[j]){
                que.push(j);
                st[j] = true;
            }
        }
    }
}
```
### 2.7 kruskal算法求最小生成树
```c
//kruskal算法
int n,m;    // n是点数，m是边数
int fth[N];    // 并查集的父节点数组

struct Edge{    // 存储边
    int a,b,w;

    bool operator< (const Edge & W)const{
        return w < W.w;
    }
}edge[M];
int find(int x){    // 并查集核心操作
    if(fth[x] != x) fth[x] = find(fth[x]);
    return fth[x];
}
int kruskal(){
    sort(edgs,edgs + m);
    for(int i = 1;i <= n;i ++ ) fth[i] = i;    // 初始化并查集
    int res = 0,cnt = 1;
    for(int i = 0;i < m;i ++ ){
        int a = edge[i].a,b = edge[i].b,w = edge[i].w;

        a = find(a),b = find(b);
        if(a != b){    // 如果两个连通块不连通，则将这两个连通块合并
            fth[a] = b;
            res += w;
            cnt ++ ;
        }
    }
    if(cnt != n) return INF;
    return res;
}
```
### 2.8 拓扑排序
```c
int d[N],count = 0;
void top_sort(){
    queue<int> que;

    for(int i = 1;i <= n;i ++ ){
        if(d[i] == 0) que.push(i),count ++ ;
    } 

    while(que.size()){
        int t = que.front();
        que.pop();

        for(int i = h[t];i != -1;i = ne[i]){
            int j = e[i];
            if( -- d[i] == 0) {
                que.push(j);
                count ++ ;
            }
        }
    }

    if(count == n){
        return true;
    }
}
```
## 3 STL（标准模板库）
```c
#include<iostream>
#include<stack>
#include<vector>
#include<queue> 
#include<set>
#include<map>
#include<unordered_map>

using namespace std;

int main(){
    stack<int> stk; // std::stack
    stk.push(1);
    stk.top();
    stk.pop();
    stk.size();


    vector<int> arr(10); // std::vector
    arr.size();
    arr.front();
    arr.back();
    arr.push_back(1);
    arr.pop_back(2);

    queue<int> que; // std::vector
    que.size();
    que.front();
    que.back();
    que.push();
    que.pop();

    priority_queue<int> heap_big; // std::priority_queue
    priority_queue<int,vector<int>,greater<int> > heap_small;
    heap_big.push();
    heap_big.pop();
    heap_big.top();

    set<int> mset_small; // std::set
    set<int,greater<int>> mset_big;
    mset_small.insert(1);
    mset_small.erase(1);
    mset_small.find(1);
    mset_small.count(1);
    //set只能用迭代器进行遍历
    for (set<int>::iterator it = mset_small.begin(); it != mset_small.end(); ++it)
    	cout << *it << endl;
    	
    map<int,int> mmap_small; // std::map
    map<int,int,greater<int>> mmap_big;
    mmap_small.find(2);
    mmap_small[1] = 0;
    mmap_small.erase(1);
    mmap_small.count(1);

    unordered_map<string,int> myhash; // std::unordermap_map
    myhash["ss"] = 1;
    myhash.count("ss");
    myhash.find("ss");
    myhash.erase("ss");
    myhash.size();

    return 0;
}
```
## 4 常用代码
### 4.1 日期合法判断
```c
int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
bool check_valid(int date){
  int year = date / 10000;
  int month = date % 10000 / 100;
  int day = date % 100;

  if(month == 0 || month > 12) return false;
  if(day == 0 || month != 2 && day > days[month]) return false;
  if(month == 2){
      int leap = year % 100 && year % 4 == 0 || year % 400 == 0;
      if(day > 28 + leap) return false;
  }
  return true;
}
```
### 4.2 c++运算符重载
```c
typedef struct MSum{
    int a;
    int b;
    int asum;

    bool operator<(const MSum &S)const{
            if(asum != S.asum) return asum < S.asum;
            if(a != S.a) return a < S.a;
            return b < S.b; 
    }

    // MSum(int a,int b): a(a),b(b){}

    void msum(){
            asum = a + b;
    } 
}MSum;
```
### 4.3 数组模拟拉链法存图
```c
int h[N],e[N],w[N],ne[N],idx;
memset(h,-1,sizeof h);
void insert(int a,int b,int c){
	e[idx] = b;
	w[idx] = c;
	ne[idx] = h[a];
	h[a] = idx ++ ;
}
```
### 4.4 字符串操作
```c
string str;
str.length();
str.back();
str.erase(pos,len);
str.find('a');
swap(str[i],str[j]);

char str[N];
scanf("%s",str);
strlen(str);
```
### 4.5 mem字节操作函数
```c
memset(dist,0x3f,sizeof dist);
memset(dist,-1,sizeof dist);
memcpy(dist1,dist2,sizeof dist1); // dist2->dist1
```
## 5 奇技淫巧
### 5.1 c++去重操作
```c
sort(alls.begin(),alls.end());                             // 先将其排序
alls.erase(unique(alls.begin(),alls.end()),alls.end());    // 在去重

unique(alls.begin(),alls.end());                           // 去除相邻相同元素只保留一个
unique(arr,arr + len);                                     // 去重（左闭右开）
sort(arr,arr + len);                                       // 排序（左闭右开）
```
### 5.2 将数字转化为字符串
```c
char str[N];
sprintf(str,"%d",i);    将数字转化为字符串
```
### 5.3 一行一行读字符串，从一行字符串中读取数据
```c
string line;
getline(cin,line); // 每次调用从cin里读入一行，下次在调用就会读入下一行（回车也会读入）
sscanf(line.c_str(),"%d:%d:%d %d:%d:%d (+%d)",&h1,&m1,&s1,&h2,&m2,&s2,&d); // 可以从line字符串里读数据，可以将需要的数据抠出来
```
### 5.4 打印前导零
```c
printf("%02d%02d%02d",&hour,&minute,&second); // 最少总共两位，用于前导零
printf("%03d%03d%03d",&hour,&minute,&second); // 最少总共三位，用于前导零，以此类推
```
## 6 特殊操作
### 6.1 string字符串和/char字符串/单个字符进行大小写转换
```c
string str;
transform(str.begin(),str.end(),str.begin(),::toupper); // string字符串全部转化为大写
transform(str.begin(),str.end(),str.begin(),::tolower); // string字符串全部转化为小写

char * p;
p = strupr(str1); // char数组类型字符串全部转化为大写
p = strlwr(str1); // char数组类型字符串全部转化为小写

c = toupper('a') // 将单个字符转化大写
    c = tolower('a') // 将单个字符转化小写
```
### 6.2 c++利用流处理进制问题
```c
// 十进制数->十六进制字符串
stringstream ss;
string ans;
ss << hex << num;
ss >> ans;
cout << ans;

// 十六进制字符串->十进制数字
stringstream ss;
int ans;
ss << hex << str;
ss >> ans;
cout << ans;

// 十进制数->八进制字符串
stringstream ss;
string ans;
ss << oct <<num;
ss >> ans;
cout << ans;

// 八进制字符串->十进制数字
stringstream ss;
int ans;
ss << oct << str;
ss >> ans;
cout << ans;

// 十进制数->二进制字符串
stringstream ss;
string ans;
ss << bitset<位数（多余补零）>(num);
ss >> ans;
cout << ans;
```
### 6.3 读取数据直到遇到文件尾，计算所有输入的值的和
```c
while（cin >> value）// 此处是重点
{
    sum += value;
}
```
### 6.4 行数是不固定的，且每行字符串多少个不固定，用逗号隔开，输出要求排序
```c
#include<sstream>
#include<iostream>
using namespace std;
int main(){
    string line;
    while (cin>>line){       // 直接读入一整行
        stringstream ss(line);   // 转化为字节流
        string str;
        vector<string> vec;
        while(getline(ss, str, ',')){  // 把整个字符串以逗号分开，读取每个string存入数组
            vec.push_back(str);
        }
    }
    排序和输出....
}
```
### 6.5 在使用C++的cin输入流读入数据时，有时会遇到给定的输入是一行不确定个数的整数
```c
while (cin >> number)
{
    input.push_back(number);
    if (cin.get() == '\n')      // 按下回车键推出循环
    break;
}
```

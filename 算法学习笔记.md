# 算法学习笔记
## 一些口诀
- dijkstra 小根堆出堆后判重
- 只有01权点最短路 dijkstra 双端队列出队后判重
- spfa 队列在不在
- bfs 队列入队前判重
- 二分 0左右、1右左（二分 左左右左、右右左右）
- dfs特顺根剪参
## 二分
### 整数二分
口诀：左左右左、右右左右
```c
int find(int k,int option){
    if(option == 0){ // 求左边界
        int l = 0,r = n - 1;
        while(l < r){
            int mid = l + (r - l >> 1);
            if(arr[mid] >= k){
                r = mid;
            }else{
                l = mid + 1;
            }
        }
    }else{ // 求右边界
        int l = 0,r = n - 1;
        while(l < r){
            int mid = l + (r - l + 1 >> 1);
            if(arr[mid] <= k){
                l = mid;
            }else{
                r = mid - 1;
            }
        }
    }
}
```
### 浮点数二分
以求n的立方根为例：
```c
double sqrt_3(double n){
    double l = -10000.0,r = 10000.0;
    while(r - l > 0.0000001){
        double mid = (l + r) / 2;
        if(mid * mid * mid <= n){
            l = mid;
        }else{
            r = mid;
        }
    }
    return l;
}
```
## STL（标准模板库）
```c
#include<iostream>
#include<stack>
#include<vector>
#include<queue> 
#include<set>
#include<map>
#include<unordered_map>

using namespace std;

int main(){
    stack<int> stk; // std::stack
    stk.push(1);
    stk.top();
    stk.pop();
    stk.size();


    vector<int> arr(10); // std::vector
    arr.size();
    arr.front();
    arr.back();
    arr.push_back(1);
    arr.pop_back(2);

    queue<int> que; // std::vector
    que.size();
    que.front();
    que.back();
    que.push();
    que.pop();

    priority_queue<int> heap_big; // std::priority_queue
    priority_queue<int,vector<int>,greater<int> > heap_small;
    heap_big.push();
    heap_big.pop();
    heap_big.top();

    set<int> mset_small; // std::set
    set<int,greater<int>> mset_big;
    mset_small.insert(1);
    mset_small.erase(1);
    mset_small.find(1);
    mset_small.count(1);
    //set只能用迭代器进行遍历
    for (set<int>::iterator it = mset_small.begin(); it != mset_small.end(); ++it)
    	cout << *it << endl;
    	
    map<int,int> mmap_small; // std::map
    map<int,int,greater<int>> mmap_big;
    mmap_small.find(2);
    mmap_small[1] = 0;
    mmap_small.erase(1);
    mmap_small.count(1);

    unordered_map<string,int> myhash; // std::unordermap_map
    myhash["ss"] = 1;
    myhash.count("ss");
    myhash.find("ss");
    myhash.erase("ss");
    myhash.size();

    return 0;
}
```
